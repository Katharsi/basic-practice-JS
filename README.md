# basic-practice-JS

*This repository contains the best tests that I was lucky enough to deal with during the training on the Hexlet platform!*

![Hexlet logo](https://open-education.net/wp-content/uploads/2014/07/416970e1e2d4bb03297ec21b80507d2a-720x340.jpg)

## *Big O*

__Big O__ - Относительное представление сложности алгоритма кода. Показывает, как будет меняться производительность алгоритма от роста входящих данных.

От роста входных данных меняются 2 параметра:

1. Время, за которое будет отрабатывать наш алгоритм.
2. Колличество памяти, используемое данным алгоритмом для обработки всего объёма данных.

Скорость роста данных параметров показывает нам __Big O__.

__Примеры сложностей__:

1.__O(1)__ - константная (постоянная) сложность.

```JavaScript
function getLastElement(arr) {
    return arr[arr.length - 1];
};

// Функция отрабатывает за константное время
// вне зависимости от колличества данных, которые поступают на вход.
```

2.__O(n)__ - линейная сложность.

```JavaScript
function getSumOfArray(arr) {
    let sum = 0;

    for(let i = 0; i < arr.length; i += 1) {
        sum += arr[i];
    }

    return sum;
};

// Линейная зависимость времени на отработку данного алгоритма от колличества входных данных.
```

3.__O(log n)__ - логарифмическая сложность.

```JavaScript
let search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    let mid;

    while (left <= right) {
        mid = Math.round(x:(right - left) / 2) + left;

        if (target === nums[mid]) {
            return mid;
        } else if (target < nums[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return -1;
};

// На каждой итерации берём массив данных и делим его на 2 части.
// Одну часть откидываем, то есть на каждой итерации мы уменьшаем объем данных вдвое.
```

4.__O(n log n)__

5.__O(n^2)__ - квадратичная сложность.

```JavaScript
function getMultiplyList(n) {
    for(let i = 1; i <= n; i++) {
        for(let j = 1; j <=n; j++) {
            console.log(`${i} * ${j} = ${i * j}`);
        }
    }
};
```

6.__O(n^3)__ - кубическая сложность.

7.__O(2^n)__ - экспоненциальная сложность.

```JavaScript
function getFib(n) {
    if (n < 2) {
        return n;
    }

    return getFib(n:n - 1) + getFib(n:n - 2);
};

// Количество операций растёт как на дрожжах.
```

8.__O(n!)__ - факториальная сложность.

![Big O](https://miro.medium.com/max/1400/1*fmbUKjjIjEprF8tiQJWgIg.png)

## bubbleSort.js

Реализуйте функцию ```bubbleSort()```

Пузырьковая сортировка (bubble sort)

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма).

__Вывод:__

```JavaScript
console.log(bubbleSort([14, 20, -10, -63, 0, 100, 33, -33]));
// [-63, -33, -10, 0, 14, 20, 33, 100]
```

## buildQueryString.js

Query String (строка запроса) - часть адреса страницы в интернете, содержащая константы и их значения. Она начинается после вопросительного знака и идет до конца адреса.

__Пример:__

```JavaScript
# query string: page=5
https://ru.hexlet.io/blog?page=5
```

Если параметров несколько, то они отделяются амперсандом __&__:

```JavaScript
# query string: page=5&per=10
https://ru.hexlet.io/blog?per=10&page=5
```

Реализуйте ```buildQueryString()```, которая принимает на вход список параметров и возвращает сформированный query string из этих параметров:

```JavaScript
buildQueryString({ per: 10, page: 1 });
// page=1&per=10
buildQueryString({ param: 'all', param1: true });
// param=all&param1=true
```

Имена параметров в выходной строке должны располагаться в алфавитном порядке (то есть их нужно отсортировать).

## capitalizeWords.js

Дана строка текста. Нужно сделать заглавной __первую__ букву каждого слова в тексте. Для простоты считаем что мы работаем с текстом, который не содержит знаков препинания.

Реализуйте функцию ```capitalizeWords()```

__Вывод:__

```JavaScript
const text = 'hello world';
capitalizeWords(text); // 'Hello World'
```

Данное задание решить через преобразование строк в массив.

## encrypt.js

Разработайте программу, которая бы шифровала сообщения по следующему алгоритму. Она бы брала текст и переставляла в нем каждые два подряд идущих символа.

__Вывод:__

```JavaScript
encrypt('JavaScript');   // 'aJavcSirtp'
encrypt('Python'); // 'yPhtno'
 
// Если число символов нечётное,
// то последний символ остаётся на своём месте
encrypt('PHP'); // 'HPP'
```

Реализуйте функцию ```encrypt()```, которая принимает на вход исходное сообщение и возвращает зашифрованное.

## fibonacci-number.js

*Чи́сла Фибона́ччи*  — элементы числовой последовательности

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, …,
в которой первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. Названы в честь средневекового математика Леонардо Пизанского (известного как Фибоначчи).

Реализуйте функцию ```fib()```. Функция вычисляет положительные числа Фибоначчи. Аргументом является порядковый номер числа.

__Формула:__

```JavaScropt
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
```

__Вывод:__

```javascript
fib(0);  // 0
fib(1);  // 1
fib(3);  // 2
fib(10); // 55
```

## findWhere.js

Реализуйте ```findWhere()```, которая принимает на вход массив (элементы которого — это объекты) и пары ключ-значение (тоже в виде объекта), а возвращает первый элемент исходного массива, значения которого соответствуют переданным парам (всем переданным). Если совпадений не было, то функция должна вернуть ```null```.

__Вывод:__

```JavaScript
findWhere(
  [
    { title: 'Book of Fooos', author: 'FooBar', year: 1111 },
    { title: 'Cymbeline', author: 'Shakespeare', year: 1611 },
    { title: 'The Tempest', author: 'Shakespeare', year: 1611 },
    { title: 'Book of Foos Barrrs', author: 'FooBar', year: 2222 },
    { title: 'Still foooing', author: 'FooBar', year: 3333 },
    { title: 'Happy Foo', author: 'FooBar', year: 4444 },
  ],
  { author: 'Shakespeare', year: 1611 }
); // { title: 'Cymbeline', author: 'Shakespeare', year: 1611 }
```

## fizzBuzz.js

Реализуйте функцию ```fizzBuzz()```, которая выводит ```(console.log)``` в терминал числа в диапазоне от begin до end. При этом:

Если число делится без остатка на 3, то вместо него выводится слово Fizz
Если число делится без остатка на 5, то вместо него выводится слово Buzz
Если число делится без остатка и на 3, и на 5, то вместо числа выводится слово FizzBuzz
В остальных случаях выводится само число
Функция принимает два параметра (begin и end), определяющих начало и конец диапазона (включительно). Для простоты считаем, что эти параметры являются целыми числами больше нуля. Если диапазон пуст (в случае, когда begin > end), то функция просто ничего не печатает.

__Вызов функции:__

```JavaScript
fizzBuzz(11, 20);
```

__Вывод в терминале:__

```JavaScript
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz

```

## getIntersectionOfSortedArrays.js

Реализуйте функцию ```getIntersectionOfSortedArrays()```, которая принимает на вход два отсортированных массива и находит их пересечение. Пересечение двух массивов A и B — это массив только с теми элементами A и B, которые одновременно принадлежат обоим массивам, без дублей.

__Вывод:__

```JavaScript
getIntersectionOfSortedArrays([10, 11, 24], [10, 13, 14, 18, 24, 30]); // [10, 24]
 
getIntersectionOfSortedArrays([10, 11, 24], [-2, 3, 4]); // []
 
getIntersectionOfSortedArrays([], [2]); // []
```

Поиск пересечения двух неотсортированных массивов — операция, в рамках которой выполняется вложенный цикл с полной проверкой каждого элемента первого массива на вхождение во второй.

Сложность данного алгоритма O(n * m) (произведение n и m), где n и m — размерности массивов. Если массивы отсортированы, то можно реализовать алгоритм, сложность которого уже O(n + m), что значительно лучше.

Суть алгоритма довольно проста. В коде вводятся два указателя (индекса) на каждый из массивов. Начальное значение каждого указателя 0. Затем идёт проверка элементов, находящихся под этими индексами в обоих массивах. Если они совпадают, то значение заносится в результирующий массив, а оба индекса инкрементируются. Если значение в первом массиве больше, чем во втором, то инкрементируется указатель второго массива, иначе — первого.

## hashTable.js

Реализуйте и экспортируйте набор функций, для работы со словарём, построенным на хеш-таблице. Для простоты, наша реализация не поддерживает разрешение коллизий.

По сути в этом задании надо реализовать объекты. По понятным причинам использовать объекты для создания объектов нельзя. Представьте что в языке объектов нет и мы их хотим добавить.

```make()``` — создаёт новый словарь
```set(map, key, value)``` — устанавливает в словарь значение по ключу. Работает и для создания и для изменения. Функция возвращает __true__, если удалось установить значение. При возникновении коллизии, функция никак не меняет словарь и возвращает __false__
```get(map, key, defaultValue = null)``` — возвращает значение указанного ключа. Параметр defaultValue — значение, которое функция возвращает, если в словаре нет ключа (по умолчанию равно null). При возникновении коллизии функция также возвращает значение по умолчанию
Функции ```set()``` и ```get()``` принимают первым параметром словарь. Передача идёт по ссылке, поэтому ```set()``` может изменить его напрямую.

__Вывод:__

```JavaScript
import { make, set, get } from './hashTable.js';
 
const map = make();
let result = get(map, 'key');
console.log(result); // => null
 
result = get(map, 'key', 'default_value');
console.log(result); // => "default_value"
 
set(map, 'key2', 'value2');
result = get(map, 'key2');
console.log(result); // => "value2"
```

Для внутреннего представления словаря, используйте массив, где индекс содержит хеш записи, а значение — key и value (их можно упаковать в массив).
Коллизии возникают, когда хеш одинаковый, а ключи разные.

## isBracketStructureBalanced.js

Реализуйте функцию ```isBracketStructureBalanced()```, которая принимает на вход строку, состоящую только из открывающих и закрывающих скобок разных типов, и проверяет, является ли эта строка сбалансированной. Открывающие и закрывающие скобки должны быть одного вида. Пустая строка (отсутствие скобок) считается сбалансированной.

Строка считается корректной (сбалансированной), если содержащаяся в ней скобочная структура соответствует требованиям:

Скобки — это парные структуры. У каждой открывающей скобки должна быть соответствующая ей закрывающая скобка.
Скобки должны закрываться в правильном порядке.

__Вывод:__

```JavaScript
// Пример вложенности
isBracketStructureBalanced('(>');  // false
isBracketStructureBalanced('()');  // true
isBracketStructureBalanced('[()]');  // true
isBracketStructureBalanced('({}[])');  // true
isBracketStructureBalanced('{<>}}'); // false
isBracketStructureBalanced('([)]'); // false
```

Функция должна поддерживать, минимум, четыре вида скобок: круглые — (), квадратные — [], фигурные — {} и угловые — <>.

## isPalindrome.js

Палиндром — число, слово или текст, одинаково читающееся в обоих направлениях. Например: радар, топот.
Реализуйте и функцию ```isPalindrome()``` с использованием рекурсии.

__Вывод:__

```JavaScript
isPalindrome('radar'); // true
isPalindrome('a');     // true
isPalindrome('abs');   // false
```

Один из способ реализовать эту функцию — попарно сравнить буквы, стоящие зеркально относительно центра. Если они совпадают, то перед нами палиндром.

Алгоритм
Если строка короче двух символов, то считается, что это палиндром.
Проверяем, совпадают ли первый и последний символы. Если нет, то это не палиндром. Если совпадают, то вызываем функцию рекурсивно, передавая внутрь строку минус первый и последний символ.
Разбор на примере: radar (палиндром)

Первый и последний символ r. Так как символы совпали, вызываем ```isPalindrome()``` рекурсивно. Дальше передаем ada
Первый и последний символ a. Так как символы совпали, вызываем ```isPalindrome()``` рекурсивно. Дальше передаем d
Так как длина строки d меньше двух символов, возвращаем true

Разбор на примере: rador (не палиндром)

Первый и последний символ r. Так как символы совпали, вызываем ```isPalindrome()``` рекурсивно. Дальше передаем ado
Первый символ a и последний символ o. Так как символы не совпали, возвращаем false

## makeItFunny.js

Напишите функцию ```makeItFunny()```, которая принимает на вход строку и возвращает её копию, у которой каждый n-ный элемент переведен в верхний регистр. n – задается на входе в функцию.

Для определения каждого n-ного элемента понадобится остаток от деления %.

__Вывод:__

```javascript
const text = 'I never look back';
// Каждый третий элемент
makeItFunny(text, 3); // 'I NevEr LooK bAck'
```
